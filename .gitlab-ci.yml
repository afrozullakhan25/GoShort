stages:
  - quality
  - security
  - test
  - build
  - deploy

variables:
  IMAGE_NAME: $CI_REGISTRY_IMAGE
  TAG_COMMIT: $CI_COMMIT_SHORT_SHA
  TAG_LATEST: latest

# ---------------------------------------------------------------------------
# Stage 1: Code Quality
# ---------------------------------------------------------------------------
lint_code:
  stage: quality
  image: golangci/golangci-lint:v1.61.0
  tags:
    - vps-runner
  script:
    - echo "Linting code..."
    - golangci-lint run --timeout 10m --verbose
  allow_failure: false



# ---------------------------------------------------------------------------
# Stage 2: Security Scan
# ---------------------------------------------------------------------------
security_scan:
  stage: security
  image: golang:1.24
  before_script:
    - go install github.com/securego/gosec/v2/cmd/gosec@latest
  script:
    - $(go env GOPATH)/bin/gosec -severity medium ./...
  tags:
    - vps-runner
  allow_failure: false



# ---------------------------------------------------------------------------
# Stage 3: Unit Tests
# ---------------------------------------------------------------------------
unit_test:
  stage: test
  image: golang:1.24
  script:
    - echo "Running unit tests..."
    - go test -v -cover ./...
  coverage: '/coverage: \d+\.\d+%/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml

# ---------------------------------------------------------------------------
# Stage 4: Build & Push Docker Image
# ---------------------------------------------------------------------------
build_push_docker:
  stage: build
  image: docker:24-cli
  services:
    - name: docker:24-dind
      command: ["--tls=false"]
  variables:
    DOCKER_TLS_CERTDIR: ""
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
  script:
    - echo "Building Docker image..."
    - docker info
    - docker build -t $IMAGE_NAME:$TAG_COMMIT -t $IMAGE_NAME:$TAG_LATEST .
    - echo "Pushing to GitLab registry..."
    - docker push $IMAGE_NAME:$TAG_COMMIT
    - docker push $IMAGE_NAME:$TAG_LATEST
  tags:
    - vps-runner
  only:
    - main
    - develop


# ---------------------------------------------------------------------------
# Stage 5: Deploy to Production VPS
# ---------------------------------------------------------------------------
deploy_prod:
  stage: deploy
  image: alpine:3.22.2
  tags:
    - vps-runner

  variables:
    SSH_PORT: "8787"

  before_script:
    - apk add --no-cache openssh-client curl bash
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -p "$SSH_PORT" -H "$SERVER_IP" >> ~/.ssh/known_hosts

  script:
    - echo "Deploying to $SERVER_IP ..."

    # ============================
    # DEPLOY BLOCK
    # ============================
    # CRITICAL FIX: Removed quotes from EOF so GitLab expands variables ($IMAGE_NAME, etc.)
    - |-
      ssh -o RequestTTY=no -p "$SSH_PORT" kagnite@"$SERVER_IP" << EOF
      set -e

      # Fix Ubuntu .bash_logout (important for non-TTY SSH)
      if [ -f ~/.bash_logout ]; then
          mv ~/.bash_logout ~/.bash_logout.bak || true
      fi

      echo "--> Login to GitLab Registry..."
      echo "$REGISTRY_DEPLOY_TOKEN" | docker login registry.gitlab.com -u "$REGISTRY_DEPLOY_USER" --password-stdin

      echo "--> Pulling latest image: $IMAGE_NAME:$TAG_LATEST"
      docker pull "$IMAGE_NAME:$TAG_LATEST"

      echo "--> Stopping old container..."
      docker stop goshort_app || true
      docker rm goshort_app || true

      echo "--> Cleaning old images..."
      docker image prune -f

      echo "--> Starting new container..."
      docker run -d \
        --name goshort_app \
        --restart always \
        -p 80:8080 \
        --log-driver json-file \
        --log-opt max-size=10m \
        --log-opt max-file=3 \
        --health-cmd='curl -f http://localhost:8080/ || exit 1' \
        --health-interval=30s \
        --health-timeout=10s \
        --health-retries=3 \
        "$IMAGE_NAME:$TAG_LATEST"

      echo "--> Container started."
      exit 0
      EOF

    # ============================
    # HEALTH CHECK BLOCK
    # ============================
    # NOTE: Quotes are KEPT here ('EOF') because we want the remote server to handle $i loop variable
    - echo "Waiting for service to become healthy..."

    - |-
      ssh -o RequestTTY=no -p "$SSH_PORT" kagnite@"$SERVER_IP" << 'EOF'
      set -e

      for i in 1 2 3 4 5 6; do
        if curl --fail --silent --max-time 5 http://localhost/ >/dev/null; then
          echo "Service is UP and Healthy!"
          exit 0
        fi
        echo "Waiting for service... attempt $i/6"
        sleep 5
      done

      echo "Service FAILED. Dumping logs:"
      docker logs --tail=50 goshort_app
      exit 1
      EOF

    - echo "Deployment successful!"

  environment:
    name: production
    url: http://$SERVER_IP

  only:
    - main

# ---------------------------------------------------------------------------
# Stage 6: Stop Production
# ---------------------------------------------------------------------------
stop_prod:
  stage: deploy
  image: alpine:latest
  tags:
    - vps-runner

  variables:
    SSH_PORT: "8787"

  before_script:
    - apk add --no-cache openssh-client
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - echo -e "Host *\n  StrictHostKeyChecking no\n" > ~/.ssh/config

  script:
    - ssh -p $SSH_PORT kagnite@$SERVER_IP "
        docker stop goshort_app || true &&
        docker rm goshort_app || true
      "

  when: manual

  environment:
    name: production
    action: stop
