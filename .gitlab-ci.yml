# ============================================
# GoShort CI/CD Pipeline
# Blue-Green Deployment with Zero Downtime
# ============================================

stages:
  - quality
  - security
  - test
  - build
  - deploy

variables:
  CI_REGISTRY_IMAGE: registry.gitlab.com/$CI_PROJECT_PATH
  TAG_COMMIT: $CI_COMMIT_SHORT_SHA
  TAG_LATEST: latest
  TAG_BRANCH: $CI_COMMIT_REF_SLUG
  DEPLOY_PATH: "/opt/goshort"
  DOCKER_DRIVER: overlay2
  DOCKER_HOST: unix:///var/run/docker.sock

# ============================================
# Backend Jobs
# ============================================

lint_backend:
  stage: quality
  image: golangci/golangci-lint:v1.61.0
  tags: [vps-runner]
  script:
    - cd backend
    - golangci-lint run --timeout 10m --verbose ./...
  only:
    - merge_requests
    - main
    - develop
  cache:
    key: ${CI_COMMIT_REF_SLUG}-backend
    paths:
      - backend/.cache

security_scan_backend:
  stage: security
  image: golang:1.23-alpine
  tags: [vps-runner]
  before_script:
    - apk add --no-cache git
    - go install github.com/securego/gosec/v2/cmd/gosec@v2.19.0
  script:
    - cd backend
    - $(go env GOPATH)/bin/gosec -severity medium -confidence medium -fmt json -out gosec-report.json ./... || echo "gosec completed with warnings"
    - $(go env GOPATH)/bin/gosec -severity medium -confidence medium ./... || true
  artifacts:
    reports:
      sast: backend/gosec-report.json
    expire_in: 1 week
    when: always
  only:
    - merge_requests
    - main
    - develop
  allow_failure: true

sast_backend:
  stage: security
  image: returntocorp/semgrep:latest
  tags: [vps-runner]
  script:
    - cd backend
    - semgrep --config auto --json --output semgrep-report.json ./... || echo "Semgrep scan completed"
    - semgrep --config auto ./... || true
  artifacts:
    reports:
      sast: backend/semgrep-report.json
    expire_in: 1 week
    when: always
  only:
    - merge_requests
    - main
    - develop
  allow_failure: true

dependency_scan_backend:
  stage: security
  image: golang:1.23-alpine
  tags: [vps-runner]
  before_script:
    - apk add --no-cache git
    - go install golang.org/x/vuln/cmd/govulncheck@latest
  script:
    - cd backend
    - $(go env GOPATH)/bin/govulncheck ./... || echo "Vulnerability scan completed"
  only:
    - merge_requests
    - main
    - develop
  allow_failure: true

unit_test_backend:
  stage: test
  image: golang:1.23-alpine
  tags: [vps-runner]
  services:
    - name: postgres:15-alpine
      alias: postgres
    - name: redis:7-alpine
      alias: redis
  variables:
    POSTGRES_DB: goshort_test
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres123
    POSTGRES_HOST_AUTH_METHOD: trust
    DB_HOST: postgres
    DB_PORT: "5432"
    DB_USER: postgres
    DB_PASSWORD: postgres123
    DB_NAME: goshort_test
    DB_SSLMODE: disable
    REDIS_HOST: redis
    REDIS_PORT: "6379"
    REDIS_PASSWORD: ""
    CGO_ENABLED: "1"
    LOG_LEVEL: error
    ENVIRONMENT: test
  before_script:
    - apk add --no-cache gcc musl-dev postgresql-client
    - |
      echo "Waiting for PostgreSQL..."
      for i in $(seq 1 30); do
        if pg_isready -h postgres -U postgres; then
          echo "PostgreSQL is ready!"
          break
        fi
        echo "Waiting... ($i/30)"
        sleep 2
      done
    - |
      echo "Waiting for Redis..."
      for i in $(seq 1 30); do
        if nc -z redis 6379; then
          echo "Redis is ready!"
          break
        fi
        echo "Waiting... ($i/30)"
        sleep 2
      done
    - cd backend
    - go mod download
  script:
    - go test -v -race -coverprofile=coverage.out -covermode=atomic ./...
    - go tool cover -func=coverage.out | tail -1
  coverage: '/total:\s+\(statements\)\s+(\d+\.\d+)%/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: backend/coverage.out
    paths:
      - backend/coverage.out
    expire_in: 1 week
    when: always
  only:
    - merge_requests
    - main
    - develop
  allow_failure: false

# ============================================
# Frontend Jobs
# ============================================

lint_frontend:
  stage: quality
  image: node:20-alpine
  tags: [vps-runner]
  before_script:
    - cd frontend
    - npm ci
  script:
    - npm run lint || true
  cache:
    key: ${CI_COMMIT_REF_SLUG}-frontend
    paths:
      - frontend/node_modules/
  only:
    - merge_requests
    - main
    - develop
  allow_failure: true

security_scan_frontend:
  stage: security
  image: node:20-alpine
  tags: [vps-runner]
  before_script:
    - cd frontend
    - npm ci
  script:
    - npm audit --audit-level=moderate || true
    - npx snyk test --severity-threshold=high || true
  only:
    - merge_requests
    - main
    - develop
  allow_failure: true

build_test_frontend:
  stage: test
  image: node:20-alpine
  tags: [vps-runner]
  before_script:
    - cd frontend
    - npm ci
  script:
    - npm run build
  artifacts:
    paths:
      - frontend/dist/
    expire_in: 1 day
  only:
    - merge_requests
    - main
    - develop

# ============================================
# Build & Push Docker Images
# ============================================

build_push_backend:
  stage: build
  image: docker:25-cli
  tags: [vps-runner]
  before_script:
    - docker info
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
  script:
    - cd backend
    - |
      docker build \
        -t $CI_REGISTRY_IMAGE/backend:$TAG_COMMIT \
        -t $CI_REGISTRY_IMAGE/backend:$TAG_BRANCH \
        -t $CI_REGISTRY_IMAGE/backend:$TAG_LATEST \
        .
    - docker push $CI_REGISTRY_IMAGE/backend:$TAG_COMMIT
    - docker push $CI_REGISTRY_IMAGE/backend:$TAG_BRANCH
    - docker push $CI_REGISTRY_IMAGE/backend:$TAG_LATEST
  only:
    - main
    - develop
  retry: 2

build_push_frontend:
  stage: build
  image: docker:25-cli
  tags: [vps-runner]
  before_script:
    - docker info
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
  script:
    - cd frontend
    - |
      docker build \
        -t $CI_REGISTRY_IMAGE/frontend:$TAG_COMMIT \
        -t $CI_REGISTRY_IMAGE/frontend:$TAG_BRANCH \
        -t $CI_REGISTRY_IMAGE/frontend:$TAG_LATEST \
        .
    - docker push $CI_REGISTRY_IMAGE/frontend:$TAG_COMMIT
    - docker push $CI_REGISTRY_IMAGE/frontend:$TAG_BRANCH
    - docker push $CI_REGISTRY_IMAGE/frontend:$TAG_LATEST
  only:
    - main
    - develop
  retry: 2

# ============================================
# Deploy to Production (Blue-Green Zero Downtime)
# ============================================

deploy_production:
  stage: deploy
  image: docker:25-cli
  tags: [vps-runner]
  before_script:
    - apk add --no-cache curl
    - mkdir -p ~/.docker/cli-plugins
    - wget -q https://github.com/docker/compose/releases/latest/download/docker-compose-linux-x86_64 -O ~/.docker/cli-plugins/docker-compose
    - chmod +x ~/.docker/cli-plugins/docker-compose
    - docker compose version
    - docker info
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
  script:
    - echo "=========================================="
    - echo "Zero-Downtime Blue-Green Deployment"
    - echo "=========================================="
    
    - mkdir -p /opt/goshort/nginx/upstreams
    - cp docker-compose.prod.yml /opt/goshort/
    - cp nginx/nginx.conf /opt/goshort/nginx/
    
    - cd /opt/goshort
    
    - echo "Checking existing nginx..."
    - |
      if docker ps --format '{{.Names}}' | grep -q nginx; then
        echo "Nginx already running"
        NGINX_EXISTS=true
      else
        echo "No nginx found, will start new"
        NGINX_EXISTS=false
      fi
    
    - echo "Starting infrastructure services..."
    - |
      if [ "$NGINX_EXISTS" = "false" ]; then
        docker compose -f docker-compose.prod.yml up -d postgres redis nginx
      else
        docker compose -f docker-compose.prod.yml up -d postgres redis
      fi
    
    - echo "Pulling latest images..."
    - docker pull $CI_REGISTRY_IMAGE/backend:$TAG_LATEST
    - docker pull $CI_REGISTRY_IMAGE/frontend:$TAG_LATEST
    
    - |
      if docker ps --format '{{.Names}}' | grep -q "goshort-backend-blue"; then
          export ACTIVE_COLOR="blue"
          export INACTIVE_COLOR="green"
      else
          export ACTIVE_COLOR="green"
          export INACTIVE_COLOR="blue"
      fi
    
    - echo "Active $ACTIVE_COLOR deploying to $INACTIVE_COLOR"
    
    - docker compose -f docker-compose.prod.yml up -d backend-${INACTIVE_COLOR}
    
    - echo "Health check for $INACTIVE_COLOR..."
    - |
      for i in $(seq 1 30); do
        if docker exec goshort-backend-${INACTIVE_COLOR} curl -f http://localhost:8080/api/v1/health >/dev/null 2>&1; then
            echo "$INACTIVE_COLOR is healthy!"
            break
        fi
        echo "Waiting... ($i/30)"
        sleep 2
      done
    
    - echo "Switching nginx config..."
    - echo "server backend-${INACTIVE_COLOR}:8080 max_fails=3 fail_timeout=30s;" > nginx/upstreams/backend_active.conf
    
    - |
      NGINX_CONTAINER=$(docker ps --format '{{.Names}}' | grep nginx | head -1 || true)
      if [ -z "$NGINX_CONTAINER" ]; then
        echo "Starting nginx..."
        docker compose -f docker-compose.prod.yml up -d nginx
        sleep 5
        NGINX_CONTAINER=$(docker ps --format '{{.Names}}' | grep nginx | head -1)
      fi
      
      echo "Waiting for nginx to be ready..."
      for i in $(seq 1 20); do
        NGINX_STATUS=$(docker inspect --format='{{.State.Status}}' $NGINX_CONTAINER 2>/dev/null || echo "not_found")
        if [ "$NGINX_STATUS" = "running" ]; then
          echo "Nginx is running!"
          break
        fi
        echo "Nginx status: $NGINX_STATUS, waiting... ($i/20)"
        sleep 3
      done
      
      echo "Using nginx container: $NGINX_CONTAINER"
      docker exec $NGINX_CONTAINER nginx -t
      docker exec $NGINX_CONTAINER nginx -s reload
    
    - echo "Updating frontend..."
    - docker compose -f docker-compose.prod.yml up -d frontend
    
    - echo "Stopping old backend $ACTIVE_COLOR..."
    - docker compose -f docker-compose.prod.yml stop backend-${ACTIVE_COLOR}
    
    - echo "=========================================="
    - echo "Deployment successful Active $INACTIVE_COLOR"
    - echo "=========================================="
    
    - docker image prune -af --filter "until=72h"
  environment:
    name: production
    url: https://kagnite.duckdns.org
  only:
    - main
  when: manual

deploy_staging:
  stage: deploy
  image: docker:25-cli
  tags: [vps-runner]
  before_script:
    - mkdir -p ~/.docker/cli-plugins
    - wget -q https://github.com/docker/compose/releases/latest/download/docker-compose-linux-x86_64 -O ~/.docker/cli-plugins/docker-compose
    - chmod +x ~/.docker/cli-plugins/docker-compose
    - docker compose version
    - docker info
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
  script:
    - mkdir -p /opt/goshort-staging
    - cp docker-compose.yml /opt/goshort-staging/
    - cd /opt/goshort-staging
    - docker compose pull
    - docker compose up -d
    - docker image prune -af --filter "until=72h"
  environment:
    name: staging
    url: https://staging.kagnite.duckdns.org
  only:
    - develop

rollback_production:
  stage: deploy
  image: docker:25-cli
  tags: [vps-runner]
  before_script:
    - mkdir -p ~/.docker/cli-plugins
    - wget -q https://github.com/docker/compose/releases/latest/download/docker-compose-linux-x86_64 -O ~/.docker/cli-plugins/docker-compose
    - chmod +x ~/.docker/cli-plugins/docker-compose
    - docker compose version
  script:
    - mkdir -p /opt/goshort/nginx/upstreams
    - cp docker-compose.prod.yml /opt/goshort/
    - cp nginx/nginx.conf /opt/goshort/nginx/
    - cd /opt/goshort
    
    - |
      if docker ps --format '{{.Names}}' | grep -q "goshort-backend-blue"; then
          export CURRENT="blue"
          export PREVIOUS="green"
      else
          export CURRENT="green"
          export PREVIOUS="blue"
      fi
    
    - echo "Rolling back from $CURRENT to $PREVIOUS"
    
    - docker compose -f docker-compose.prod.yml up -d backend-${PREVIOUS}
    
    - sleep 10
    
    - echo "server backend-${PREVIOUS}:8080 max_fails=3 fail_timeout=30s;" > nginx/upstreams/backend_active.conf
    
    - |
      NGINX_CONTAINER=$(docker ps --format '{{.Names}}' | grep nginx | head -1 || true)
      if [ -n "$NGINX_CONTAINER" ]; then
        echo "Waiting for nginx to be ready..."
        for i in $(seq 1 20); do
          NGINX_STATUS=$(docker inspect --format='{{.State.Status}}' $NGINX_CONTAINER 2>/dev/null || echo "not_found")
          if [ "$NGINX_STATUS" = "running" ]; then
            echo "Nginx is running!"
            docker exec $NGINX_CONTAINER nginx -s reload
            break
          fi
          echo "Nginx status: $NGINX_STATUS, waiting... ($i/20)"
          sleep 3
        done
      else
        echo "No nginx container found"
      fi
    
    - echo "Rollback completed to $PREVIOUS"
  environment:
    name: production
  when: manual
  only:
    - main
